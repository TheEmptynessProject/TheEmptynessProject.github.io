<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Palette Generator</title>
    <style>
        :root {
            --primary: #4a6fa5;
            --secondary: #166088;
            --light: #f5f5f5;
            --dark: #333333;
            --accent: #ff6b6b;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: var(--light);
            color: var(--dark);
            line-height: 1.6;
        }
        
        header {
            background-color: var(--primary);
            color: white;
            text-align: center;
            padding: 2rem 0;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .section {
            background-color: white;
            border-radius: 8px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }
        
        h1, h2, h3 {
            margin-bottom: 1rem;
        }
        
        .controls {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
        
        @media (min-width: 768px) {
            .controls {
                grid-template-columns: 1fr 1fr;
            }
        }
        
        .control-group {
            margin-bottom: 1rem;
        }
        
        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }
        
        input[type="range"] {
            width: 100%;
            margin-bottom: 0.5rem;
        }
        
        input[type="color"] {
            width: 100%;
            height: 50px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .btn {
            background-color: var(--secondary);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.2s ease;
        }
        
        .btn:hover {
            background-color: var(--primary);
        }
        
        .btn-group {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }
        
        .palette {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 1rem;
            margin-top: 2rem;
        }
        
        .color-card {
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease;
        }
        
        .color-card:hover {
            transform: translateY(-5px);
        }
        
        .color-block {
            height: 120px;
        }
        
        .color-info {
            padding: 1rem;
            background-color: white;
        }
        
        .color-values {
            font-size: 0.9rem;
            display: grid;
            gap: 0.25rem;
        }
        
        .color-value {
            background-color: #f5f5f5;
            padding: 0.25rem 0.5rem;
            border-radius: 3px;
            font-family: monospace;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        
        .color-value:hover {
            background-color: #e9e9e9;
        }
        
        .export-section {
            margin-top: 2rem;
        }
        
        .lock-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.7);
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        
        .lock-btn:hover {
            background-color: rgba(255, 255, 255, 0.9);
        }
        
        .locked .lock-btn {
            background-color: var(--accent);
            color: white;
        }
        
        .color-card {
            position: relative;
        }
        
        #exportModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 8px;
            max-width: 600px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
        }
        
        textarea {
            width: 100%;
            height: 120px;
            padding: 0.5rem;
            margin-bottom: 1rem;
            font-family: monospace;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .tooltip {
            position: fixed;
            background-color: var(--dark);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 1000;
        }
        
        .rule-section {
            margin-top: 1rem;
        }

    </style>
</head>
<body>
    <header>
        <h1>Color Palette Generator</h1>
        <p>Create beautiful color combinations with ease</p>
    </header>
    
    <div class="container">
        <div class="section">
            <h2>Base Color</h2>
            <div class="controls">
                <div>
                    <div class="control-group">
                        <label for="baseColor">Select Base Color</label>
                        <input type="color" id="baseColor" value="#4a6fa5">
                    </div>
                    
                    <div class="control-group">
                        <label for="hueSlider">Hue: <span id="hueValue">210</span>Â°</label>
                        <input type="range" id="hueSlider" min="0" max="360" value="210">
                    </div>
                    
                    <div class="control-group">
                        <label for="saturationSlider">Saturation: <span id="saturationValue">50</span>%</label>
                        <input type="range" id="saturationSlider" min="0" max="100" value="50">
                    </div>
                    
                    <div class="control-group">
                        <label for="lightnessSlider">Lightness: <span id="lightnessValue">50</span>%</label>
                        <input type="range" id="lightnessSlider" min="0" max="100" value="50">
                    </div>
                </div>
                
                <div>
                    <h3>Generate Palette</h3>
                    <div class="btn-group">
                        <button id="randomBtn" class="btn">Random</button>
                        <button id="complementaryBtn" class="btn">Complementary</button>
                        <button id="analogousBtn" class="btn">Analogous</button>
                        <button id="triadicBtn" class="btn">Triadic</button>
                        <button id="tetradicBtn" class="btn">Tetradic</button>
                        <button id="monochromaticBtn" class="btn">Monochromatic</button>
                    </div>
                    
                    <div class="control-group">
                        <label for="paletteSize">Palette Size</label>
                        <input type="range" id="paletteSize" min="3" max="8" value="5">
                        <div><span id="paletteSizeValue">5</span> colors</div>
                    </div>
                </div>
            </div>
            
            <div class="palette" id="colorPalette">
                <!-- Color cards will be generated here -->
            </div>
            
            <div class="export-section">
                <button id="exportBtn" class="btn">Export Palette</button>
            </div>
        </div>
    </div>
    
    <div id="exportModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Export Palette</h2>
                <button class="close-btn">&times;</button>
            </div>
            
            <div class="export-options">
                <h3>HEX Values</h3>
                <textarea id="hexExport" readonly></textarea>
                
                <h3>RGB Values</h3>
                <textarea id="rgbExport" readonly></textarea>
                
                <h3>HSL Values</h3>
                <textarea id="hslExport" readonly></textarea>
                
                <h3>CSS Variables</h3>
                <textarea id="cssExport" readonly></textarea>
            </div>
            
            <button id="copyBtn" class="btn">Copy All</button>
        </div>
    </div>
    
    <div class="tooltip" id="tooltip"></div>
    
    <script>
        // DOM Elements
        const baseColorInput = document.getElementById('baseColor');
        const hueSlider = document.getElementById('hueSlider');
        const saturationSlider = document.getElementById('saturationSlider');
        const lightnessSlider = document.getElementById('lightnessSlider');
        const hueValueDisplay = document.getElementById('hueValue');
        const saturationValueDisplay = document.getElementById('saturationValue');
        const lightnessValueDisplay = document.getElementById('lightnessValue');
        const paletteSize = document.getElementById('paletteSize');
        const paletteSizeValue = document.getElementById('paletteSizeValue');
        const colorPalette = document.getElementById('colorPalette');
        const exportBtn = document.getElementById('exportBtn');
        const exportModal = document.getElementById('exportModal');
        const closeBtn = document.querySelector('.close-btn');
        const copyBtn = document.getElementById('copyBtn');
        const tooltip = document.getElementById('tooltip');
        
        // Palette buttons
        const randomBtn = document.getElementById('randomBtn');
        const complementaryBtn = document.getElementById('complementaryBtn');
        const analogousBtn = document.getElementById('analogousBtn');
        const triadicBtn = document.getElementById('triadicBtn');
        const tetradicBtn = document.getElementById('tetradicBtn');
        const monochromaticBtn = document.getElementById('monochromaticBtn');
        
        // Current palette and locked colors
        let currentPalette = [];
        let lockedColors = [];
        let currentRule = 'random';
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            updateBaseColorFromHSL();
            generatePalette('random');
            setupEventListeners();
        });
        
        function setupEventListeners() {
            // Color input and sliders
            baseColorInput.addEventListener('input', updateHSLFromColorPicker);
            hueSlider.addEventListener('input', updateFromHSLSliders);
            saturationSlider.addEventListener('input', updateFromHSLSliders);
            lightnessSlider.addEventListener('input', updateFromHSLSliders);
            
            // Palette generation buttons
            randomBtn.addEventListener('click', () => generatePalette('random'));
            complementaryBtn.addEventListener('click', () => generatePalette('complementary'));
            analogousBtn.addEventListener('click', () => generatePalette('analogous'));
            triadicBtn.addEventListener('click', () => generatePalette('triadic'));
            tetradicBtn.addEventListener('click', () => generatePalette('tetradic'));
            monochromaticBtn.addEventListener('click', () => generatePalette('monochromatic'));
            
            // Palette size
            paletteSize.addEventListener('input', () => {
                paletteSizeValue.textContent = paletteSize.value;
                generatePalette(currentRule);
            });
            
            // Export modal
            exportBtn.addEventListener('click', showExportModal);
            closeBtn.addEventListener('click', hideExportModal);
            window.addEventListener('click', (e) => {
                if (e.target === exportModal) {
                    hideExportModal();
                }
            });
            
            // Copy button
            copyBtn.addEventListener('click', copyAllFormats);
            
            // Close tooltip after a delay
            document.addEventListener('mouseover', (e) => {
                if (e.target.classList.contains('color-value')) {
                    const text = e.target.textContent;
                    showTooltip(text, e.pageX, e.pageY - 30, 'Click to copy');
                }
            });
            
            document.addEventListener('mouseout', (e) => {
                if (e.target.classList.contains('color-value')) {
                    hideTooltip();
                }
            });
        }
        
        // Color conversion functions
        function hexToHSL(hex) {
            let r = parseInt(hex.substring(1, 3), 16) / 255;
            let g = parseInt(hex.substring(3, 5), 16) / 255;
            let b = parseInt(hex.substring(5, 7), 16) / 255;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0; // achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                
                h /= 6;
            }
            
            return {
                h: Math.round(h * 360),
                s: Math.round(s * 100),
                l: Math.round(l * 100)
            };
        }
        
        function hslToHex(h, s, l) {
            h /= 360;
            s /= 100;
            l /= 100;
            
            let r, g, b;
            
            if (s === 0) {
                r = g = b = l; // achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            
            const toHex = (x) => {
                const hex = Math.round(x * 255).toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            };
            
            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }
        
        function hslToRGB(h, s, l) {
            h /= 360;
            s /= 100;
            l /= 100;
            
            let r, g, b;
            
            if (s === 0) {
                r = g = b = l; // achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            
            return {
                r: Math.round(r * 255),
                g: Math.round(g * 255),
                b: Math.round(b * 255)
            };
        }
        
        // Update functions
        function updateHSLFromColorPicker() {
            const hex = baseColorInput.value;
            const hsl = hexToHSL(hex);
            
            hueSlider.value = hsl.h;
            saturationSlider.value = hsl.s;
            lightnessSlider.value = hsl.l;
            
            hueValueDisplay.textContent = hsl.h;
            saturationValueDisplay.textContent = hsl.s;
            lightnessValueDisplay.textContent = hsl.l;
            
            generatePalette(currentRule);
        }
        
        function updateFromHSLSliders() {
            const h = parseInt(hueSlider.value);
            const s = parseInt(saturationSlider.value);
            const l = parseInt(lightnessSlider.value);
            
            hueValueDisplay.textContent = h;
            saturationValueDisplay.textContent = s;
            lightnessValueDisplay.textContent = l;
            
            const hex = hslToHex(h, s, l);
            baseColorInput.value = hex;
            
            generatePalette(currentRule);
        }
        
        function updateBaseColorFromHSL() {
            const h = parseInt(hueSlider.value);
            const s = parseInt(saturationSlider.value);
            const l = parseInt(lightnessSlider.value);
            
            const hex = hslToHex(h, s, l);
            baseColorInput.value = hex;
        }
        
        // Palette generation
        function generatePalette(rule) {
            currentRule = rule;
            const baseHue = parseInt(hueSlider.value);
            const baseSaturation = parseInt(saturationSlider.value);
            const baseLightness = parseInt(lightnessSlider.value);
            const size = parseInt(paletteSize.value);
            
            let colors = [];
            
            switch (rule) {
                case 'random':
                    colors = generateRandomPalette(size);
                    break;
                case 'complementary':
                    colors = generateComplementaryPalette(baseHue, baseSaturation, baseLightness, size);
                    break;
                case 'analogous':
                    colors = generateAnalogousPalette(baseHue, baseSaturation, baseLightness, size);
                    break;
                case 'triadic':
                    colors = generateTriadicPalette(baseHue, baseSaturation, baseLightness, size);
                    break;
                case 'tetradic':
                    colors = generateTetradicPalette(baseHue, baseSaturation, baseLightness, size);
                    break;
                case 'monochromatic':
                    colors = generateMonochromaticPalette(baseHue, baseSaturation, baseLightness, size);
                    break;
                default:
                    colors = generateRandomPalette(size);
            }
            
            // Apply locked colors
            for (let i = 0; i < lockedColors.length; i++) {
                if (lockedColors[i] && i < colors.length) {
                    colors[i] = lockedColors[i];
                }
            }
            
            // Update current palette
            currentPalette = colors;
            
            // Render palette
            renderPalette(colors);
        }
        
        function generateRandomPalette(size) {
            const colors = [];
            
            for (let i = 0; i < size; i++) {
                const h = Math.floor(Math.random() * 360);
                const s = 70 + Math.floor(Math.random() * 30); // 70-100% saturation
                const l = 40 + Math.floor(Math.random() * 30); // 40-70% lightness
                
                colors.push({ h, s, l });
            }
            
            return colors;
        }
        
        function generateComplementaryPalette(baseHue, baseSaturation, baseLightness, size) {
            const colors = [];
            const complementaryHue = (baseHue + 180) % 360;
            
            // Add base color
            colors.push({ h: baseHue, s: baseSaturation, l: baseLightness });
            
            // Add tints and shades of base color
            if (size >= 3) {
                colors.push({ h: baseHue, s: baseSaturation, l: Math.min(baseLightness + 20, 95) });
                colors.push({ h: baseHue, s: baseSaturation, l: Math.max(baseLightness - 20, 15) });
            }
            
            // Add complementary color
            colors.push({ h: complementaryHue, s: baseSaturation, l: baseLightness });
            
            // Add tints and shades of complementary color if needed
            if (size >= 5) {
                colors.push({ h: complementaryHue, s: baseSaturation, l: Math.min(baseLightness + 20, 95) });
            }
            if (size >= 6) {
                colors.push({ h: complementaryHue, s: baseSaturation, l: Math.max(baseLightness - 20, 15) });
            }
            
            // Add additional variations if needed
            while (colors.length < size) {
                const useBase = colors.length % 2 === 0;
                const hue = useBase ? baseHue : complementaryHue;
                const saturationOffset = -15 + Math.floor(Math.random() * 30);
                const lightnessOffset = -15 + Math.floor(Math.random() * 30);
                
                colors.push({
                    h: hue,
                    s: Math.max(0, Math.min(100, baseSaturation + saturationOffset)),
                    l: Math.max(15, Math.min(95, baseLightness + lightnessOffset))
                });
            }
            
            return colors;
        }
        
        function generateAnalogousPalette(baseHue, baseSaturation, baseLightness, size) {
            const colors = [];
            const angle = 30;
            
            // Add base color
            colors.push({ h: baseHue, s: baseSaturation, l: baseLightness });
            
            // Add analogous colors
            for (let i = 1; i < size; i++) {
                const offset = Math.floor(i / 2) * angle * (i % 2 === 0 ? -1 : 1);
                let hue = (baseHue + offset + 360) % 360;
                
                colors.push({
                    h: hue,
                    s: baseSaturation,
                    l: baseLightness
                });
            }
            
            return colors;
        }
        
        function generateTriadicPalette(baseHue, baseSaturation, baseLightness, size) {
            const colors = [];
            const angle = 120;
            
            // Add the three triadic colors
            colors.push({ h: baseHue, s: baseSaturation, l: baseLightness });
            colors.push({ h: (baseHue + angle) % 360, s: baseSaturation, l: baseLightness });
            colors.push({ h: (baseHue + 2 * angle) % 360, s: baseSaturation, l: baseLightness });
            
            // Add variations if needed
            let colorIndex = 0;
            while (colors.length < size) {
                const baseColor = colors[colorIndex % 3];
                colors.push({
                    h: baseColor.h,
                    s: baseColor.s,
                    l: colors.length % 2 === 0 
                        ? Math.min(baseColor.l + 20, 90)
                        : Math.max(baseColor.l - 20, 20)
                });
                colorIndex++;
            }
            
            return colors;
        }
        
        function generateTetradicPalette(baseHue, baseSaturation, baseLightness, size) {
            const colors = [];
            
            // Add the four tetradic colors
            colors.push({ h: baseHue, s: baseSaturation, l: baseLightness });
            colors.push({ h: (baseHue + 90) % 360, s: baseSaturation, l: baseLightness });
            colors.push({ h: (baseHue + 180) % 360, s: baseSaturation, l: baseLightness });
            colors.push({ h: (baseHue + 270) % 360, s: baseSaturation, l: baseLightness });
            
            // Add variations if needed
            let colorIndex = 0;
            while (colors.length < size) {
                const baseColor = colors[colorIndex % 4];
                colors.push({
                    h: baseColor.h,
                    s: baseColor.s,
                    l: colors.length % 2 === 0 
                        ? Math.min(baseColor.l + 15, 85)
                        : Math.max(baseColor.l - 15, 25)
                });
                colorIndex++;
            }
            
            return colors;
        }
        
        function generateMonochromaticPalette(baseHue, baseSaturation, baseLightness, size) {
            const colors = [];
            const lightnessStep = 70 / (size - 1);
            
            for (let i = 0; i < size; i++) {
                const l = Math.max(15, Math.min(95, 20 + i * lightnessStep));
                colors.push({ h: baseHue, s: baseSaturation, l });
            }
            
            return colors;
        }
        
        // UI Functions
        function renderPalette(colors) {
            colorPalette.innerHTML = '';
            
            colors.forEach((color, index) => {
                const isLocked = lockedColors[index] !== undefined;
                const hex = hslToHex(color.h, color.s, color.l);
                const rgb = hslToRGB(color.h, color.s, color.l);
                
                const colorCard = document.createElement('div');
                colorCard.className = `color-card ${isLocked ? 'locked' : ''}`;
                colorCard.dataset.index = index;
                
                const colorBlock = document.createElement('div');
                colorBlock.className = 'color-block';
                colorBlock.style.backgroundColor = hex;
                
                const lockBtn = document.createElement('button');
                lockBtn.className = 'lock-btn';
                lockBtn.innerHTML = isLocked ? 'ð' : 'ð';
                lockBtn.addEventListener('click', () => toggleLock(index));
                
                const colorInfo = document.createElement('div');
                colorInfo.className = 'color-info';
                
                const colorValues = document.createElement('div');
                colorValues.className = 'color-values';
                
                const hexValue = document.createElement('div');
                hexValue.className = 'color-value';
                hexValue.textContent = hex;
                hexValue.addEventListener('click', () => copyToClipboard(hex));
                
                const rgbValue = document.createElement('div');
                rgbValue.className = 'color-value';
                rgbValue.textContent = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
                rgbValue.addEventListener('click', () => copyToClipboard(`rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`));
                
                const hslValue = document.createElement('div');
                hslValue.className = 'color-value';
                hslValue.textContent = `hsl(${color.h}, ${color.s}%, ${color.l}%)`;
                hslValue.addEventListener('click', () => copyToClipboard(`hsl(${color.h}, ${color.s}%, ${color.l}%)`));
                
                colorValues.appendChild(hexValue);
                colorValues.appendChild(rgbValue);
                colorValues.appendChild(hslValue);
                
                colorInfo.appendChild(colorValues);
                colorBlock.appendChild(lockBtn);
                colorCard.appendChild(colorBlock);
                colorCard.appendChild(colorInfo);
                
                colorPalette.appendChild(colorCard);
            });
        }
        
        function toggleLock(index) {
            if (lockedColors[index]) {
                delete lockedColors[index];
            } else {
                lockedColors[index] = currentPalette[index];
            }
            
            renderPalette(currentPalette);
        }
        
        function showExportModal() {
            // Generate export content
            const hexExport = document.getElementById('hexExport');
            const rgbExport = document.getElementById('rgbExport');
            const hslExport = document.getElementById('hslExport');
            const cssExport = document.getElementById('cssExport');
            
            hexExport.value = currentPalette.map((color, index) => {
                const hex = hslToHex(color.h, color.s, color.l);
                return `Color ${index + 1}: ${hex}`;
            }).join('\n');
            
            rgbExport.value = currentPalette.map((color, index) => {
                const rgb = hslToRGB(color.h, color.s, color.l);
                return `Color ${index + 1}: rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
            }).join('\n');
            
            hslExport.value = currentPalette.map((color, index) => {
                return `Color ${index + 1}: hsl(${color.h}, ${color.s}%, ${color.l}%)`;
            }).join('\n');
            
            cssExport.value = currentPalette.map((color, index) => {
                const hex = hslToHex(color.h, color.s, color.l);
                return `--color-${index + 1}: ${hex};`;
            }).join('\n');
            
            // Show modal
            exportModal.style.display = 'flex';
        }
        
        function hideExportModal() {
            exportModal.style.display = 'none';
        }
        
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text)
                .then(() => {
                    showTooltip(text, event.pageX, event.pageY - 30, 'Copied!');
                    setTimeout(hideTooltip, 1500);
                })
                .catch(err => {
                    console.error('Failed to copy: ', err);
                });
        }
        
        function copyAllFormats() {
            const hexExport = document.getElementById('hexExport').value;
            const rgbExport = document.getElementById('rgbExport').value;
            const hslExport = document.getElementById('hslExport').value;
            const cssExport = document.getElementById('cssExport').value;
            
            const allFormats = `HEX VALUES\n${hexExport}\n\nRGB VALUES\n${rgbExport}\n\nHSL VALUES\n${hslExport}\n\nCSS VARIABLES\n${cssExport}`;
            
            navigator.clipboard.writeText(allFormats)
                .then(() => {
                    copyBtn.textContent = 'Copied!';
                    setTimeout(() => {
                        copyBtn.textContent = 'Copy All';
                    }, 2000);
                })
                .catch(err => {
                    console.error('Failed to copy: ', err);
                });
        }
        
        function showTooltip(text, x, y, message) {
            tooltip.textContent = message || text;
            tooltip.style.left = `${x}px`;
            tooltip.style.top = `${y}px`;
            tooltip.style.opacity = '1';
        }
        
        function hideTooltip() {
            tooltip.style.opacity = '0';
        }
        
        // Initialize the palette
        generatePalette('random');
    </script>
</body>
</html>