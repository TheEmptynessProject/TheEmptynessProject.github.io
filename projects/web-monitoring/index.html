<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   Clipboard Monitor
  </title>
  <style>
   body {
            font-family: monospace;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }

        #clipboardContent {
            border: 1px solid #ddd;
            padding: 10px;
            margin: 10px 0;
            background: white;
            min-height: 50px;
        }

        button {
            background: #333;
            color: white;
            border: none;
            padding: 5px 10px;
            margin: 5px;
            cursor: pointer;
        }

        #history {
            margin-top: 20px;
            border: 1px solid #ddd;
            background: white;
            height: 400px;
            overflow-y: auto;
        }

        .history-entry {
            padding: 5px;
            border-bottom: 1px solid #eee;
            font-size: 12px;
        }

        .event-type {
            color: #666;
        }

        .timestamp {
            color: #999;
        }

        .content {
            word-break: break-all;
        }
  </style>
 </head>
 <body>
  <button id="permissionBtn">
   Enable Monitoring
  </button>
  <div id="clipboardContent">
  </div>
  <div id="history">
  </div>
  <script>
   let initialClipboardData = '';
        let hasPermission = false;

        
        let activeApplication = '';
        let clipboardSource = '';
        let lastModified = null;

        
        class HistoryEntry {
            constructor(type, content = '', details = '') {
                this.timestamp = new Date();
                this.type = type;
                this.content = content;
                this.details = details;
                this.windowTitle = document.title;
                this.url = window.location.href;
                this.activeApp = activeApplication;
                this.source = clipboardSource;
                this.modifiedTime = lastModified;
                
                if (window.chrome && chrome.tabs) {
                    chrome.tabs.query({active: true, currentWindow: true}, function(tabs) {
                        this.tabInfo = tabs[0];
                    });
                }
                this.browserInfo = this.getBrowserInfo();
                this.networkStatus = navigator.onLine ? 'online' : 'offline';
                this.memory = this.getMemoryInfo();
                this.preciseTime = performance.now();
                this.mimeType = this.detectContentType(content);
                this.idleTime = this.getIdleTime();
                this.systemInfo = {
                    screenSize: `${window.screen.width}x${window.screen.height}`,
                    colorDepth: window.screen.colorDepth,
                    pixelRatio: window.devicePixelRatio,
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
                };
                this.mousePosition = lastMousePosition;
                this.windowSize = {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    scrollX: window.scrollX,
                    scrollY: window.scrollY
                };
            }

            getBrowserInfo() {
                const ua = navigator.userAgent;
                return {
                    userAgent: ua,
                    language: navigator.language,
                    platform: navigator.platform,
                    vendor: navigator.vendor,
                    cookiesEnabled: navigator.cookieEnabled,
                    doNotTrack: navigator.doNotTrack,
                    hardwareConcurrency: navigator.hardwareConcurrency,
                    maxTouchPoints: navigator.maxTouchPoints
                };
            }

            getMemoryInfo() {
                if (performance.memory) {
                    return {
                        jsHeapSizeLimit: performance.memory.jsHeapSizeLimit,
                        totalJSHeapSize: performance.memory.totalJSHeapSize,
                        usedJSHeapSize: performance.memory.usedJSHeapSize
                    };
                }
                return null;
            }

            detectContentType(content) {
                if (!content) return 'empty';
                if (content.startsWith('data:')) return 'base64';
                if (content.match(/^[\w\-]+:\/\
                if (content.match(/<[^>]+>/)) return 'html';
                if (content.match(/^[\w\-]+=[^\s]/)) return 'key-value';
                return 'plain-text';
            }

            getIdleTime() {
                return performance.now() - lastActivityTime;
            }
        }

        let history = [];
        let lastActiveWindow = '';
        let lastActiveTab = '';
        let lastActivityTime = performance.now();
        let lastKeyCombo = [];
        const keyboardShortcuts = new Set();
        let lastKeyboardShortcutTime = 0;
        const KEYBOARD_DEBOUNCE_TIME = 300; 

        function addHistoryEntry(entry) {
            history.unshift(entry);
            updateHistoryDisplay();
        }

        
        function updateHistoryDisplay() {
            const historyDiv = document.getElementById('history');
            historyDiv.innerHTML = history.map(entry => `
                <div class="history-entry">
                    <span class="timestamp">${entry.timestamp.toLocaleTimeString()}.${entry.timestamp.getMilliseconds()}</span>
                    <span class="event-type">[${entry.type}]</span>
                    <div class="details">
                        ${entry.details}
                        ${entry.source ? `<br>Source: ${entry.source}` : ''}
                        ${entry.mimeType ? `<br>Content Type: ${entry.mimeType}` : ''}
                        ${entry.networkStatus ? `<br>Network: ${entry.networkStatus}` : ''}
                        ${entry.systemInfo ? `<br>Screen: ${entry.systemInfo.screenSize}` : ''}
                        ${entry.memory ? `<br>Memory Usage: ${Math.round(entry.memory.usedJSHeapSize/1048576)}MB` : ''}
                        ${entry.idleTime ? `<br>Idle Time: ${Math.round(entry.idleTime/1000)}s` : ''}
                        ${entry.mousePosition ? `<br>Mouse: (${entry.mousePosition.x}, ${entry.mousePosition.y})` : ''}
                        ${entry.windowSize ? `<br>Window: ${entry.windowSize.width}x${entry.windowSize.height}` : ''}
                    </div>
                    ${entry.content ? `
                        <div class="content">
                            <pre>${entry.content.substring(0, 100)}${entry.content.length > 100 ? '...' : ''}</pre>
                        </div>
                    ` : ''}
                </div>
            `).join('');
        }

        
        window.addEventListener('focus', async function() {
            const entry = new HistoryEntry('FOCUS_GAIN', '', `Window gained focus at ${new Date().toLocaleTimeString()}`);
            addHistoryEntry(entry);
            
            if (!hasPermission) return;
            
            try {
                const startTime = performance.now();
                const currentContent = await navigator.clipboard.readText();
                const endTime = performance.now();

                if (currentContent !== initialClipboardData) {
                    clipboardSource = document.hidden ? 'background' : 'other_window';
                    const clipboardEntry = new HistoryEntry(
                        'CLIPBOARD_CHANGE',
                        currentContent,
                        `Clipboard changed at ${new Date().toLocaleTimeString()}\nDelay: ${(endTime - startTime).toFixed(2)}ms\nPrevious: ${initialClipboardData.substring(0, 50)}...`
                    );
                    addHistoryEntry(clipboardEntry);
                    updateClipboardContent(currentContent);
                }
            } catch (error) {
                console.error('Clipboard check error:', error);
            }
        });

        window.addEventListener('blur', function(e) {
            const entry = new HistoryEntry('FOCUS_LOSS', '', 'Window lost focus');
            addHistoryEntry(entry);
        });

        
        document.addEventListener('copy', function(e) {
            const text = window.getSelection().toString();
            const entry = new HistoryEntry('COPY', text, `Text copied at ${new Date().toLocaleTimeString()}`);
            addHistoryEntry(entry);
        });

        document.addEventListener('cut', function(e) {
            const text = window.getSelection().toString();
            const entry = new HistoryEntry('CUT', text, `Text cut at ${new Date().toLocaleTimeString()}`);
            addHistoryEntry(entry);
        });

        document.addEventListener('paste', async function(e) {
            if (hasPermission) {
                e.preventDefault();
                const text = e.clipboardData.getData('text');
                const entry = new HistoryEntry('PASTE', text, `Text pasted at ${new Date().toLocaleTimeString()}`);
                addHistoryEntry(entry);
                updateClipboardContent(text);
            }
        });

        
        document.addEventListener('visibilitychange', async function() {
            if (!hasPermission) return;
            
            const state = document.hidden ? 'hidden' : 'visible';
            if (!document.hidden) {
                try {
                    const currentContent = await navigator.clipboard.readText();
                    if (currentContent !== initialClipboardData) {
                        const entry = new HistoryEntry(
                            'TAB_VISIBILITY_CLIPBOARD_CHANGE',
                            currentContent,
                            `Content changed while tab was hidden\nPrevious: ${initialClipboardData.substring(0, 50)}...`
                        );
                        addHistoryEntry(entry);
                        updateClipboardContent(currentContent);
                    }
                } catch (error) {
                    console.error('Visibility clipboard check error:', error);
                }
            }
            
            const entry = new HistoryEntry(
                'VISIBILITY_CHANGE',
                '',
                `Tab ${state} (${new Date().toISOString()})`
            );
            addHistoryEntry(entry);
        });

        
        document.getElementById('permissionBtn').addEventListener('click', async () => {
            try {
                const initialContent = await navigator.clipboard.readText();
                hasPermission = true;
                document.getElementById('permissionBtn').style.display = 'none';
                updateClipboardContent(initialContent);
                const entry = new HistoryEntry('PERMISSION', initialContent, 'Clipboard monitoring enabled');
                addHistoryEntry(entry);
            } catch (error) {
                const entry = new HistoryEntry('ERROR', '', 'Permission denied');
                addHistoryEntry(entry);
                alert('Permission denied');
            }
        });

        
        window.addEventListener('beforeunload', function(e) {
            const entry = new HistoryEntry('TAB_CLOSE', '', 'Tab being closed');
            addHistoryEntry(entry);
        });

        
        document.addEventListener('mouseleave', function(e) {
            lastMousePosition = { x: e.clientX, y: e.clientY };
            if (e.clientY <= 0 || e.clientX <= 0 || 
                e.clientX >= window.innerWidth || 
                e.clientY >= window.innerHeight) {
                const entry = new HistoryEntry(
                    'MOUSE_EXIT',
                    '',
                    `Mouse left window at (${e.clientX}, ${e.clientY})`
                );
                addHistoryEntry(entry);
            }
        });

        
        let lastMousePosition = { x: 0, y: 0 };

        
        document.addEventListener('mouseenter', function(e) {
            lastMousePosition = { x: e.clientX, y: e.clientY };
            const entry = new HistoryEntry(
                'MOUSE_ENTER',
                '',
                `Mouse entered at (${e.clientX}, ${e.clientY})`
            );
            addHistoryEntry(entry);
        });

        document.addEventListener('mousedown', function(e) {
            lastMousePosition = { x: e.clientX, y: e.clientY };
            const buttonMap = ['Left', 'Middle', 'Right'];
            const entry = new HistoryEntry(
                'MOUSE_CLICK',
                '',
                `${buttonMap[e.button]} button clicked at (${e.clientX}, ${e.clientY})`
            );
            addHistoryEntry(entry);
        });

        
        let resizeTimeout;
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                const entry = new HistoryEntry(
                    'WINDOW_RESIZE',
                    '',
                    `Window resized to ${window.innerWidth}x${window.innerHeight}`
                );
                addHistoryEntry(entry);
            }, 500);
        });

        
        let scrollTimeout;
        document.addEventListener('scroll', function() {
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                const entry = new HistoryEntry(
                    'PAGE_SCROLL',
                    '',
                    `Scrolled to position: ${window.scrollX}px, ${window.scrollY}px`
                );
                addHistoryEntry(entry);
            }, 300);
        });

        function updateClipboardContent(content) {
            const clipboardContentEl = document.getElementById('clipboardContent');
            clipboardContentEl.textContent = content;
            initialClipboardData = content;
        }

        function updateStatus(message) {
            const timestamp = new Date().toLocaleTimeString();
            const statusEl = document.getElementById('status');
            statusEl.innerHTML = `<small>${timestamp}</small> - ${message}`;
        }

        
        document.addEventListener('keydown', (e) => {
            const now = performance.now();
            if (now - lastKeyboardShortcutTime < KEYBOARD_DEBOUNCE_TIME) {
                return;
            }
            
            lastActivityTime = now;
            lastKeyCombo.push(e.key);
            if (lastKeyCombo.length > 3) lastKeyCombo.shift();
            
            const combo = lastKeyCombo.join('+');
            if ((e.ctrlKey || e.metaKey) && e.key !== 'Control' && e.key !== 'Meta') {
                keyboardShortcuts.add(`${e.ctrlKey ? 'Ctrl' : 'Cmd'}+${e.key}`);
                const entry = new HistoryEntry(
                    'KEYBOARD_SHORTCUT',
                    combo,
                    `Shortcut detected at ${new Date().toLocaleTimeString()}\nAll shortcuts: ${Array.from(keyboardShortcuts).join(', ')}`
                );
                addHistoryEntry(entry);
                lastKeyboardShortcutTime = now;
            }
        });

        
        window.addEventListener('online', () => {
            const entry = new HistoryEntry('NETWORK_CHANGE', '', 'Connection restored');
            addHistoryEntry(entry);
        });

        window.addEventListener('offline', () => {
            const entry = new HistoryEntry('NETWORK_CHANGE', '', 'Connection lost');
            addHistoryEntry(entry);
        });

        
        let idleCheckInterval = setInterval(() => {
            const idleTime = performance.now() - lastActivityTime;
            if (idleTime > 60000) { 
                const entry = new HistoryEntry('IDLE_STATE', '', `System idle for ${Math.floor(idleTime/1000)}s`);
                addHistoryEntry(entry);
            }
        }, 30000);
  </script>
 </body>
</html>
