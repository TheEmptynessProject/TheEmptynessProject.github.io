<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   Minesweeper
  </title>
  <style>
   body {
      font-family: 'Arial', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #f0f0f0;
      color: #333;
    }

    .game-container {
      background-color: #ccc;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      margin-top: 20px;
    }

    .controls {
      display: flex;
      justify-content: space-between;
      margin-bottom: 20px;
      gap: 15px;
    }

    .controls select, .controls button {
      padding: 8px;
      border-radius: 4px;
      border: 1px solid #999;
    }

    .game-info {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
    }

    .counter {
      background-color: #222;
      color: #f00;
      font-family: monospace;
      font-size: 24px;
      padding: 5px 10px;
      border-radius: 4px;
    }

    .game-board {
      display: grid;
      grid-template-columns: repeat(var(--grid-size), 30px);
      grid-gap: 1px;
      margin-top: 10px;
    }

    .cell {
      width: 30px;
      height: 30px;
      background-color: #bbb;
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: bold;
      cursor: pointer;
      box-shadow: inset 2px 2px 2px rgba(255, 255, 255, 0.5),
                 inset -2px -2px 2px rgba(0, 0, 0, 0.3);
    }

    .cell:hover {
      background-color: #aaa;
    }

    .revealed {
      background-color: #ddd;
      box-shadow: none;
    }

    .mine {
      background-color: #f00;
    }

    .flag {
      background-color: #bbb;
      position: relative;
    }

    .flag::after {
      content: 'ðŸš©';
      font-size: 16px;
    }

    .number-1 { color: blue; }
    .number-2 { color: green; }
    .number-3 { color: red; }
    .number-4 { color: darkblue; }
    .number-5 { color: brown; }
    .number-6 { color: teal; }
    .number-7 { color: black; }
    .number-8 { color: gray; }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      z-index: 100;
      justify-content: center;
      align-items: center;
    }

    .modal-content {
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
      width: 300px;
    }

    .modal-title {
      font-size: 24px;
      margin-bottom: 15px;
    }

    .high-scores {
      width: 100%;
      max-width: 500px;
      margin-top: 20px;
    }

    .high-scores h2 {
      text-align: center;
    }

    table {
      width: 100%;
      border-collapse: collapse;
    }

    th, td {
      padding: 8px;
      text-align: left;
      border-bottom: 1px solid #ddd;
    }

    th {
      background-color: #f2f2f2;
    }
  </style>
 </head>
 <body>
  <h1>
   Minesweeper
  </h1>
  <div class="game-container">
   <div class="controls">
    <select id="difficulty">
     <option value="beginner">
      Beginner (9x9, 10 mines)
     </option>
     <option value="intermediate">
      Intermediate (16x16, 40 mines)
     </option>
     <option value="expert">
      Expert (16x30, 99 mines)
     </option>
     <option value="custom">
      Custom
     </option>
    </select>
    <div id="custom-controls" style="display: none;">
     <input id="custom-width" max="50" min="5" placeholder="Width" type="number" value="10"/>
     <input id="custom-height" max="50" min="5" placeholder="Height" type="number" value="10"/>
     <input id="custom-mines" max="2500" min="1" placeholder="Mines" type="number" value="10"/>
    </div>
    <button id="new-game">
     New Game
    </button>
   </div>
   <div class="game-info">
    <div class="counter" id="mine-counter">
     000
    </div>
    <div class="counter" id="timer">
     000
    </div>
   </div>
   <div class="game-board" id="board">
   </div>
  </div>
  <div class="high-scores">
   <h2>
    High Scores
   </h2>
   <table id="high-scores-table">
    <thead>
     <tr>
      <th>
       Difficulty
      </th>
      <th>
       Time
      </th>
      <th>
       Date
      </th>
     </tr>
    </thead>
    <tbody id="high-scores-body">
    </tbody>
   </table>
  </div>
  <div class="modal" id="result-modal">
   <div class="modal-content">
    <h2 class="modal-title" id="result-title">
    </h2>
    <p id="result-message">
    </p>
    <p id="result-time">
    </p>
    <button id="play-again">
     Play Again
    </button>
   </div>
  </div>
  <script>
   class Minesweeper {
      constructor() {
        this.board = document.getElementById('board');
        this.mineCounter = document.getElementById('mine-counter');
        this.timerDisplay = document.getElementById('timer');
        this.resultModal = document.getElementById('result-modal');
        this.resultTitle = document.getElementById('result-title');
        this.resultMessage = document.getElementById('result-message');
        this.resultTime = document.getElementById('result-time');
        this.difficultySelect = document.getElementById('difficulty');
        this.customControls = document.getElementById('custom-controls');
        this.highScoresBody = document.getElementById('high-scores-body');
        
        this.width = 9;
        this.height = 9;
        this.mines = 10;
        this.difficulty = 'beginner';
        this.cells = [];
        this.mineLocations = [];
        this.flaggedCells = [];
        this.revealedCells = [];
        this.gameOver = false;
        this.timerInterval = null;
        this.startTime = null;
        this.elapsedTime = 0;
        
        
        document.getElementById('new-game').addEventListener('click', () => this.setupGame());
        document.getElementById('play-again').addEventListener('click', () => {
          this.resultModal.style.display = 'none';
          this.setupGame();
        });
        
        this.difficultySelect.addEventListener('change', () => {
          if (this.difficultySelect.value === 'custom') {
            this.customControls.style.display = 'block';
          } else {
            this.customControls.style.display = 'none';
          }
        });
        
        
        this.loadHighScores();
        this.setupGame();
      }
      
      setupGame() {
        
        clearInterval(this.timerInterval);
        this.board.innerHTML = '';
        this.cells = [];
        this.mineLocations = [];
        this.flaggedCells = [];
        this.revealedCells = [];
        this.gameOver = false;
        this.startTime = null;
        this.elapsedTime = 0;
        this.timerDisplay.textContent = '000';
        
        
        this.difficulty = this.difficultySelect.value;
        switch (this.difficulty) {
          case 'beginner':
            this.width = 9;
            this.height = 9;
            this.mines = 10;
            break;
          case 'intermediate':
            this.width = 16;
            this.height = 16;
            this.mines = 40;
            break;
          case 'expert':
            this.width = 30;
            this.height = 16;
            this.mines = 99;
            break;
          case 'custom':
            this.width = Math.min(50, Math.max(5, parseInt(document.getElementById('custom-width').value, 10) || 10));
            this.height = Math.min(50, Math.max(5, parseInt(document.getElementById('custom-height').value, 10) || 10));
            const maxMines = this.width * this.height - 1;
            this.mines = Math.min(maxMines, Math.max(1, parseInt(document.getElementById('custom-mines').value, 10) || 10));
            document.getElementById('custom-width').value = this.width;
            document.getElementById('custom-height').value = this.height;
            document.getElementById('custom-mines').value = this.mines;
            break;
        }
        
        
        this.updateMineCounter();
        
        
        this.board.style.setProperty('--grid-size', this.width);
        this.createBoard();
      }
      
      createBoard() {
        
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.x = x;
            cell.dataset.y = y;
            
            
            cell.addEventListener('click', (e) => this.handleCellClick(x, y));
            
            
            cell.addEventListener('contextmenu', (e) => {
              e.preventDefault();
              this.handleRightClick(x, y);
            });
            
            this.board.appendChild(cell);
            this.cells.push({
              element: cell,
              x,
              y,
              isMine: false,
              isRevealed: false,
              isFlagged: false,
              neighborMines: 0
            });
          }
        }
      }
      
      startTimer() {
        if (this.startTime === null) {
          this.startTime = Date.now();
          this.timerInterval = setInterval(() => {
            this.elapsedTime = Math.floor((Date.now() - this.startTime) / 1000);
            this.timerDisplay.textContent = this.elapsedTime.toString().padStart(3, '0');
          }, 1000);
        }
      }
      
      placeMines(firstClickX, firstClickY) {
        let minesPlaced = 0;
        const totalCells = this.width * this.height;
        
        
        const safeArea = [];
        for (let y = Math.max(0, firstClickY - 1); y <= Math.min(this.height - 1, firstClickY + 1); y++) {
          for (let x = Math.max(0, firstClickX - 1); x <= Math.min(this.width - 1, firstClickX + 1); x++) {
            safeArea.push(y * this.width + x);
          }
        }
        
        while (minesPlaced < this.mines) {
          const randomIndex = Math.floor(Math.random() * totalCells);
          if (!this.mineLocations.includes(randomIndex) && !safeArea.includes(randomIndex)) {
            this.mineLocations.push(randomIndex);
            minesPlaced++;
            
            const x = randomIndex % this.width;
            const y = Math.floor(randomIndex / this.width);
            const cellIndex = y * this.width + x;
            this.cells[cellIndex].isMine = true;
          }
        }
        
        
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            const cellIndex = y * this.width + x;
            if (!this.cells[cellIndex].isMine) {
              this.cells[cellIndex].neighborMines = this.countNeighborMines(x, y);
            }
          }
        }
      }
      
      countNeighborMines(x, y) {
        let count = 0;
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            const nx = x + dx;
            const ny = y + dy;
            if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height) {
              const cellIndex = ny * this.width + nx;
              if (this.cells[cellIndex].isMine) {
                count++;
              }
            }
          }
        }
        return count;
      }
      
      handleCellClick(x, y) {
        if (this.gameOver) return;
        
        const cellIndex = y * this.width + x;
        const cell = this.cells[cellIndex];
        
        
        if (cell.isFlagged) return;
        
        
        if (this.revealedCells.length === 0) {
          this.placeMines(x, y);
          this.startTimer();
        }
        
        
        if (cell.isMine) {
          this.revealMines();
          this.endGame(false);
          return;
        }
        
        this.revealCell(x, y);
        
        
        this.checkWin();
      }
      
      handleRightClick(x, y) {
        if (this.gameOver) return;
        
        const cellIndex = y * this.width + x;
        const cell = this.cells[cellIndex];
        
        
        if (cell.isRevealed) return;
        
        if (cell.isFlagged) {
          
          cell.isFlagged = false;
          cell.element.classList.remove('flag');
          const flagIndex = this.flaggedCells.indexOf(cellIndex);
          if (flagIndex !== -1) {
            this.flaggedCells.splice(flagIndex, 1);
          }
        } else {
          
          cell.isFlagged = true;
          cell.element.classList.add('flag');
          this.flaggedCells.push(cellIndex);
        }
        
        this.updateMineCounter();
      }
      
      revealCell(x, y) {
        const cellIndex = y * this.width + x;
        const cell = this.cells[cellIndex];
        
        if (cell.isRevealed || cell.isFlagged) return;
        
        cell.isRevealed = true;
        cell.element.classList.add('revealed');
        this.revealedCells.push(cellIndex);
        
        if (cell.neighborMines > 0) {
          cell.element.textContent = cell.neighborMines;
          cell.element.classList.add(`number-${cell.neighborMines}`);
        } else {
          
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              const nx = x + dx;
              const ny = y + dy;
              if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height) {
                this.revealCell(nx, ny);
              }
            }
          }
        }
      }
      
      revealMines() {
        this.mineLocations.forEach(mineIndex => {
          const cell = this.cells[mineIndex];
          cell.element.classList.add('revealed', 'mine');
          cell.element.textContent = 'ðŸ’£';
        });
      }
      
      updateMineCounter() {
        const remainingMines = this.mines - this.flaggedCells.length;
        this.mineCounter.textContent = remainingMines.toString().padStart(3, '0');
      }
      
      checkWin() {
        const remainingUnrevealedCells = this.width * this.height - this.revealedCells.length;
        if (remainingUnrevealedCells === this.mines) {
          
          this.cells.forEach((cell, index) => {
            if (cell.isMine && !cell.isFlagged) {
              cell.isFlagged = true;
              cell.element.classList.add('flag');
              this.flaggedCells.push(index);
            }
          });
          
          this.updateMineCounter();
          this.endGame(true);
        }
      }
      
      endGame(isWin) {
        this.gameOver = true;
        clearInterval(this.timerInterval);
        
        if (isWin) {
          this.resultTitle.textContent = 'You Win!';
          this.resultMessage.textContent = 'Congratulations! You found all the mines!';
          this.saveHighScore();
        } else {
          this.resultTitle.textContent = 'Game Over';
          this.resultMessage.textContent = 'You hit a mine. Better luck next time!';
        }
        
        this.resultTime.textContent = `Time: ${this.elapsedTime} seconds`;
        this.resultModal.style.display = 'flex';
      }
      
      saveHighScore() {
        if (this.difficulty === 'custom') return; 
        
        const highScores = this.getHighScores();
        
        highScores.push({
          difficulty: this.difficulty,
          time: this.elapsedTime,
          date: new Date().toLocaleDateString()
        });
        
        
        const sortedScores = highScores
          .sort((a, b) => a.time - b.time)
          .reduce((acc, score) => {
            const diffScores = acc[score.difficulty] || [];
            if (diffScores.length < 5) {
              diffScores.push(score);
            }
            acc[score.difficulty] = diffScores;
            return acc;
          }, {});
        
        localStorage.setItem('minesweeperHighScores', JSON.stringify(sortedScores));
        this.loadHighScores();
      }
      
      getHighScores() {
        const savedScores = localStorage.getItem('minesweeperHighScores');
        if (!savedScores) return [];
        
        try {
          const parsedScores = JSON.parse(savedScores);
          
          return Object.values(parsedScores).flat();
        } catch (e) {
          return [];
        }
      }
      
      loadHighScores() {
        const savedScores = localStorage.getItem('minesweeperHighScores');
        this.highScoresBody.innerHTML = '';
        
        if (!savedScores) return;
        
        try {
          const parsedScores = JSON.parse(savedScores);
          
          for (const difficulty in parsedScores) {
            parsedScores[difficulty].forEach(score => {
              const row = document.createElement('tr');
              
              const diffCell = document.createElement('td');
              diffCell.textContent = difficulty.charAt(0).toUpperCase() + difficulty.slice(1);
              
              const timeCell = document.createElement('td');
              timeCell.textContent = `${score.time} seconds`;
              
              const dateCell = document.createElement('td');
              dateCell.textContent = score.date;
              
              row.appendChild(diffCell);
              row.appendChild(timeCell);
              row.appendChild(dateCell);
              
              this.highScoresBody.appendChild(row);
            });
          }
        } catch (e) {
          console.error('Error loading high scores:', e);
        }
      }
    }

    
    document.addEventListener('DOMContentLoaded', () => {
      const game = new Minesweeper();
    });
  </script>
 </body>
</html>
